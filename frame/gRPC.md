## 什么是gRPC

通过gRPC，客户端可以像调用本地方法一样调用在不同机器上的服务端方法，极大的方便用户构建一个分布式程序和服务。 gRPC 它基于定义服务，确定的方法和相应的参数进行远程调用，然后返回相应的类型。

### http2.0 优势
- 传输采用二进制格式，而非文本格式
- 多路复用-http1.1 协议同一客户端同一时间，对同一域名下的请求有一定数量限制
- header 压缩技术
- 服务端推送

### service 定义
```
  service HelloService {
    // 支持四种类型的 service 方法

    // Unary RPCs 1. 一个请求 一个返回
    rpc SayHello (HelloRequest) returns (HelloResponse);
    // server streaming RPCs 2. 单个请求，返回消息流, 一系列的消息
    rpc SayHello (HelloRequest) returns (stream HelloResponse);
    // Client streaming RPCs 3. 一系列的请求， 单个返回
    rpc SayHello (stream HelloRequest) returns (HelloResponse);
    // Bidirectional streaming RPCs 4. 请求，返回都是 一系列。
  }

  message HelloRequest {
    string greeting = 1;
  }

  message HelloResponse {
    string reply = 1;
  }
```

### 职责

首先，在 .proto 定义一个service， gRPC 通过「protocol buffer」编译插件生成客户端和服务端代码。用户一般在客户端调用这些api，实现服务端的这些 API 的接口。

server :  server 实现了 service 定义的接口，运行一个 gRPC 服务，接受客户端的调用。gRPC 应用解码进入的请求，执行服务器方法，编码返回的数据。
client : 客户端有一个本地的 stub 对象，它实现了相同的 service 端的方法。 然后，客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的协议缓冲区消息类型中 - gRPC 在将请求发送到服务器并返回服务器的协议缓冲区响应之后查看。

## 微服务设计六大原则
- 高内聚低耦合
- 高度自治
- 以业务为中心
- 日志与监控
- 弹性设计
- 自动化

## 分布式基础理论 CAP 和 Paxox
### CAP
- C： consistency， 一致性
- A:  availability，可用性
- P: partition， 分布容忍性
### Paxos 
集群：多个人在一起干作同样的事
分布式 ：多个人在一起干不同的事

## 分布式事务四种方式
1. 两阶段提交（2PC）也叫 XA方案
> 通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务
  - 准备阶段 prepare （执行了事务，但还未提交）
  - 提交阶段 commit （事务都执行成功，才提交）
  **存在的问题**：
    - 同步阻塞，所有事务参与者等待其他事务响应前只能处于阻塞状态，如果某个服务挂了，整个系统不可用。效率太低，不适合高并发
    - 单点问题，协调者在其中起的作用太大，发生故障会造成很大影响
    - 数据不一致，在第二阶段，如果由于网路问题，协调者只发生了部分commit消息，有部分参与者没有提交
  
1. 补偿事务（TCC方案）
> 其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作
  - Try： 对各个服务的资源做检测，锁定或者预留
  - Confirm： 各个服务执行实际的操作
  - Cancel： 如果任意一个服务的业务方法出现错误，那么其他服务就需要执行补偿操作
优点： 跟2PC比起来，实现以及流程相对简单了一些
缺点： TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理
1. 本地消息表
> 本地消息表和业务数据表处于同一个数据库，这样可以保证对俩个表的操作满足事务特征。并且使用消息队列保证最终一致性
  - 在分布式事务的 A完成业务操作后，同时往本地消息表写入一条数据。本地事务可以保证 原子性
  - 之后将本地消息表中的消息发送到消息队列（Kafka），
  - 分布式事务的另一方B从消息队列读取消息，执行消息中的操作同时往自己本地消息表里插入一条数据。如果成功，修改本地和A消息表消息状态，如果失败，A会定时检测本地消息表状态，继续发送消息

  优点： 避免了分布式事务，实现了最终一致性
  缺点： 消息表会耦合到业务中
1. 可靠消息最终一致性方案（MQ 事务消息）
- A系统首先发送一个prepared消息到消息服务mq，如果这个prepared消息发送失败，那么就直接取消操作，不再进行任何操作执行了。
- 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉消息服务mq发送确认消息，如果失败就告诉消息服务mq回滚消息
- 如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务
- 消息服务mq会自动定时轮询所有prepared消息回调相应服务接口，询问这个消息是不是本地事务处理失败了，所以没发送确认消息？是继续重试还是回滚？一般来说可以查下数据库查看之前的本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息发送失败了。
- 可靠消息最终一致性方案里要是系统B的事务失败了怎么办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿。

