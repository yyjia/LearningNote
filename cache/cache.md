#### ORM缓存 ####
- 基本理念是： 减少数据库服务器磁盘IO为最终目的，而不是减少发送到数据库的sql条数。
- 数据库schema设计 尽量细颗粒度的表，颗粒度越小， 缓存对象对象的单位越小，缓存的使用场景越广泛。
- 尽量避免多表关联查询， 尽量拆分成多个表单独的主键

#### 更新缓存四种设计模式 #####
- Cache Aside

  ***失效*** 应用先从cache 取数据， 没有再从数据库取回数据，存放进cache， 然后返回数据 

  ***命中*** 应用从cache 中直接返回数据

  ***更新*** 首先更新数据库，如果数据库更新成功，缓存失效，重新从数据库获取数据

  特点： 应用代码需要维护俩个数据存储
- read/write through
  在 Cache Aside的基础上，把数据库更新的操作由缓存自己代理，应用认为后端是单一的存储。

  ***Read Through*** 当缓存失效的时候（过期或者LRU换出）,Cache Aside是由调用方负责把数据
  加入缓存，Read through则由缓存服务自己来加载。

  ***Write Through*** 与read through相仿，只是在更新数据库的时候， 如果没有命中缓存， 则直接更新数据库，
  更新成功，然后返回。如果命中缓存，则直接更新缓存，然后由缓存服务器更新数据库（同步操作）
  
  ***LRU替换算法***，每次淘汰最久没有使用的元素
- Write Behind Caching Pattern
  更新数据库的时候，只更新缓存， 不更新数据库，我们的缓存会异步的批量更新数据库。
  特点： 因为是异步，性能提升大，数据不是强一致性。 

