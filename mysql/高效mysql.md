## 事务
### 事务的特性（ACID）
- 原子性（atomicity）  最小的工作单元
- 一致性（consistency） 只能由一种状态到另一种状态，中间没有其他状态
- 隔离性（isolation） 一个事务的修改，在提交前，对其他事物不可见
- 持久性 (durability) 事务提交后，修改永久有效

#### 事务隔离级别
- Read Uncommitted (未提交读)
- Read Committed（读提交）
- Repeatable Read (可重复读) mysql 默认隔离级别
- Seralizable （可串行化）强制事物串行化

#### 死锁 - 常用解决策略
> 俩个或者多个事务在同一个资源上相互占用，并请求锁定对方占用的资源

- 超过获取锁的等待时间，自动放弃获取锁
- 持有最少资源行级排他锁的事务回滚

#### 事务日志 
> 数据每次修改，1、 修改内存拷贝； 2、 操作添加到持久在磁盘上的事务日志， 故需要写俩次磁盘

## 索引
### 索引的优点
- 索引大大减少服务器要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机 I/O 变为 顺序 I/O

### 索引类型
- B-Tree 索引 -- 基于 B+ 树索引实现
    - 支持查询
        - 值是按顺序存储的
        - 遵循最左前缀
        - 支持全值匹配，匹配列前缀和范围匹配
        - 只访问索引
    - 限制查询
        - 如果不是按照索引的最左列开始查找，则无法使用索引
        - 不能跳过索引中的列
        - 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询
- hash 索引 --- 基于哈希表实现 （memory 引擎）
    - 存储的时候没有排序，所以不能按照范围查询使用
    - 只有精准匹配索引所有列的查询才有效
- 空间数据索引（R-Tree）（ MyISAM 引擎 ）
- 全文索引 （只适用于 match against 操作）


## 优化
- 库表结构优化
    - 数据类型的选取
        - 更小的通常更好
        - 简单就好
        > 整数优于字符，日期使用内置日期类型，ip存储为整数
        - 尽量避免 NULL
- 索引优化
    - 高效索引策略
        - 独立的列，索引不能是表达式的一部分、函数的参数
        - 前缀索引和索引选择性
        - 多列索引
        - 选择合适的索引列顺序，当不考虑排序和分组的时候，将选择性最高的列放在前面
        > select count(distinct staff_id)/count(*) as staff_selective, </br>
        > count(distict customer_id)/count(*) as customer_selective, </br>
        > count(\*)</br>
        > from payment \G </br>
        > ########### 1 row ############# </br>
        >    staff_selective: 0.0001 </br>
        > customer_selective: 0.0373 </br>
        >           count(*): 16049 </br>
        >  
        > customer_id 选择性更大，所以选择 （customer_id， staff_id） 而是 （staff_id， customer_id）
        - 聚簇索引，InnoDB聚簇索引实际上是在同一结构中保存了B-Tree 索引和数据行
        - 覆盖索引，一个索引包含全部需要查询的列 
        - 冗余和重复索引
        - 未使用的索引，应该删除掉
- 查询优化
> 查询的生命周期：从客户端，到服务器，服务器（解析器，预处理器，查询优化器），生成执行计划，查询执行引擎，并返回客户端

- 慢查询
    - 是否向数据库请求了不需要的数据
    - mysql 是否在扫描额外的记录
    > 慢日志记录了每个查询的 1，响应时间 2，扫描行数 3， 返回行数
- 重构查询方式
    - 复杂查询和简单查询取舍
    - 切分查询
    - 分解关联查询
- 
    